<!DOCTYPE html>
<html>

<head>
  <style>
    /* Makes the page fill the window. */

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
  </style>
  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
</head>

<body>
  <div id="container" style="width:100%; height:100%; display: flex; flex-direction: column; align-items: stretch">
    <div id="map" style="flex-grow: 1"></div>
    <div id="alt-chart" style="flex-basis:20%"></div>
  </div>

  <script>
    window.currentTrackPointId = 595;
    window.calculatedThermailsViews = [];
    var map;
    function initMap() {
      window.map = new google.maps.Map(document.getElementById('map'), {
        zoom: 12,
        center: { lat: 46.48991, lng: 11.7614 },
        mapTypeId: 'terrain'
      });

      console.log("Rendering thermails from XCGlobe")
      renderTrackThermails(window.map, window.flightBoxData.thermails);

      console.log("Rendering flight track");
      renderTrack(window.map, window.trackData);

      console.log("Render initial plane location");
      window.planeMarker = renderPlane(map, null, window.trackData.points[window.currentTrackPointId]);
    }
  </script>

  <script>
    // Rendering routines
    function renderTrackThermails(map, thermails) {
      for (therm of thermails) {
        renderThermail(map, therm, {
          zIndex: 100,
          fillColor: 'blue',
          zIndex: 0
        });
      };
    }

    function renderCalculatedThermailsForTrackPointId(trackPointId, map, thermails) {
      const countOfPriorThermailsToShow = 2;
      const nearestThermailIdx = -1 + thermails.findIndex(function (therm) {
        return therm.trackPointId > trackPointId
      });
      console.log("trackPointId = ", trackPointId);
      console.log("NearestThermailIdx = ", nearestThermailIdx);
      if (nearestThermailIdx < 0) {
        return [];
      }

      const startIdx = Math.max(0, nearestThermailIdx - countOfPriorThermailsToShow);
      const endIdx = nearestThermailIdx;

      thermailViews = [];
      for (let i = startIdx; i <= endIdx; i++) {
        const therm = thermails[i];
        const opacity = 0.1 + 0.4 * (i - startIdx) / (endIdx - startIdx); // from 0.1 to 0.5
        const thermView = renderThermail(map, therm, {
          zIndex: 100,
          fillColor: determinationColor(therm.r2),
          fillOpacity: opacity
        });
        thermailViews.push(thermView);
      };

      return thermailViews;
    }

    function renderAllCalculatedThermails(map, thermails) {
      for (therm of thermails) {
        renderThermail(map, therm, {
          zIndex: 100,
          fillColor: determinationColor(therm.r2)
        });
      };
    }

    function renderThermail(map, therm, options) {
      circle = new google.maps.Circle({
        map: map,
        center: therm.center,
        radius: therm.radius,
        fillOpacity: 0.5,
        strokeWeight: 1,
        ...options
      });
      return circle;
    }

    function destroyRenderedThermail(thermailView) {
      console.debug("Destroying thermail");
      thermailView.setMap(null);
    }

    function renderTrack(trackData) {
      new google.maps.Polyline({
        map: map, //FIXME: add as parameter
        path: window.trackData.points,
        strokeWeight: 2,
        strokeColor: 'yellow'
      });
    }

    function renderPlane(map, planeMarker, point) {
      let marker = planeMarker;
      if (!marker) {
        marker = new google.maps.Marker({
          map: map,
          icon: {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 4,
            strokeColor: 'red'
          }
        });
      }

      console.debug("Plane point: ", point);
      marker.setPosition(point);
      return marker;
    }

    function determinationColor(determinationCoeff) {
      // Assuming 0.60 is the lowest determination possible
      const minCoeffValue = 0.6;
      const trimmedValue = Math.max(determinationCoeff - minCoeffValue, 0);
      const normalizedValue = trimmedValue / (1 - minCoeffValue);
      return redYellowGreenLerp(normalizedValue);
    }

    function redYellowGreenLerp(value) {
      // Color linear interpolation
      // red color for 0,
      // yellow for 0.5,
      // green for 1.0
      const lowHue = 0; //red
      const hightHue = 120; //green
      const hue = lowHue + (hightHue - lowHue) * value;
      return 'hsl(' + hue + ', 100%, 50%)';
    }
  </script>
  <script>
    // Load the Visualization API and the corechart package.
    google.charts.load('current', { 'packages': ['corechart'] });

    // Set a callback to run when the Google Visualization API is loaded.
    google.charts.setOnLoadCallback(drawChart);

    // Callback that creates and populates a data table,
    // instantiates the pie chart, passes in the data and
    // draws it.
    function drawChart() {

      // Create the data table.
      var data = new google.visualization.DataTable();
      data.addColumn('number', 'Point Idx');
      data.addColumn('number', 'Altitude');

      const rows = window.trackData.points.map(function (point, idx) {
        return [idx, point.alt];
      })

      data.addRows(rows);

      var options = {
        curveType: 'function',
        legend: 'none',
        chartArea: {'width': '100%', 'height': '100%', top: 10, bottom:10, right:10, left:50},
        tooltip: {
          trigger: 'none'
        }
      };

      // Instantiate and draw our chart, passing in some options.
      window.trackChart = new google.visualization.LineChart(document.getElementById('alt-chart'));
      window.trackChart.draw(data, options);

      google.visualization.events.addListener(window.trackChart, 'onmouseover', onMouseOverChartHandler);
    }

  </script>
  <script>
    // Data loading routines
    function flightBoxDataFetchedCallback(data) {
      console.log("Thermails loaded: ", data.thermails.length);
      window.flightBoxData = data;
    }

    function calculatedDataFetchedCallback(data) {
      console.log("Thermails loaded: ", data.thermails.length);
      window.calculatedData = data;
    }

    function trackDataFetchedCallback(data) {
      console.log("Track is loaded");
      window.trackData = data;
    }
  </script>

  <script>
    // User interaction handling
    function handleKeyPress(e) {
      console.log(`Key ${e.code} pressed`);

      const trackPointsCount = window.trackData.points.length;
      if (e.code === 'KeyD') {
        window.currentTrackPointId = Math.min(window.currentTrackPointId + 1, trackPointsCount);
      } else if (e.code === 'KeyA') {
        window.currentTrackPointId = Math.max(window.currentTrackPointId - 1, 0);
      } else {
        return;
      }

      updateViewForCurrentTrackPointId(window.currentTrackPointId);
    }

    window.addEventListener('keydown', handleKeyPress);

    function onMouseOverChartHandler(e) {
      console.debug("Chart onMouseOver fired: ", e);
      window.currentTrackPointId = e.row;
      updateViewForCurrentTrackPointId(window.currentTrackPointId);
    }

    function updateViewForCurrentTrackPointId(trackPointId) {
      // Render new position of plane
      const currentTrackPoint = window.trackData.points[trackPointId];
      window.planeMarker = renderPlane(window.map, window.planeMarker, currentTrackPoint);

      //  Get previously rendered calculated thermails
      const thermailsViewsToDestroy = window.calculatedThermailsViews;

      // Render new thermails
      window.calculatedThermailsViews = renderCalculatedThermailsForTrackPointId(
        trackPointId,
        window.map,
        window.calculatedData.thermails
      );

      // Remove previously rendered calculated thermails
      thermailsViewsToDestroy.forEach(destroyRenderedThermail);

      if (!map.getBounds().contains(currentTrackPoint)) {
        map.panTo(currentTrackPoint);
      }

      window.trackChart.setSelection([{row:window.currentTrackPointId, column: null }]);
    }
  </script>
  <script src="data/xc-thermails.js"></script>
  <script src="data/calculated_thermails.js"></script>
  <script src="data/igc-track.js"></script>
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCM-8hga1cAOBlE2a9ssL95G3SCMXh5B8o&callback=initMap"></script>

</body>

</html>